from PySide6.QtWidgets import *
from PySide6.QtCore import *
from PySide6.QtGui import *

from PySide6 import QtCore, QtWidgets

from random import randint, choice

class CheckBoxDelegate(QtWidgets.QItemDelegate):
    """
    A delegate that places a fully functioning QCheckBox cell of the column to which it's applied.

    From https://stackoverflow.com/questions/17748546/pyqt-column-of-checkboxes-in-a-qtableview
    """
    def __init__(self, parent):
        QtWidgets.QItemDelegate.__init__(self, parent)

    def createEditor(self, parent, option, index):
        """
        Important, otherwise an editor is created if the user clicks in this cell.
        """
        return None

    def paint(self, painter, option, index):
        """
        Paint a checkbox without the label.
        """
        self.drawCheck(painter, option, option.rect, QtCore.Qt.Unchecked if int(index.data()) == 0 else QtCore.Qt.Checked)

    def editorEvent(self, event, model, option, index):
        '''
        Change the data in the model and the state of the checkbox
        if the user presses the left mousebutton and this cell is editable. Otherwise do nothing.
        '''

        if not int(index.flags() & QtCore.Qt.ItemIsEditable) > 0:
            print(int(index.flags()))
            return False

        if event.type() == QtCore.QEvent.Type.MouseButtonRelease and event.button() == Qt.MouseButton.LeftButton:
            # Change the checkbox-state
            self.setModelData(None, model, index)
            return True

        return False


    def setModelData (self, editor, model, index):
        '''
        Invert checkbox on click.

        Affects proxy: 
        https://forum.qt.io/topic/121874/how-to-access-source-model-methods-from-proxy-model,
        https://doc.qt.io/qt-5/qabstractproxymodel.html#mapToSource
        '''
        #print(index.row(), index.column())

        source_index = self.parent().proxy.mapToSource(index)
        data = self.parent().table_model.data(source_index, Qt.DisplayRole)
        data = int(not bool(data)) # Invert 1 -> 0 or 0 -> 1

        self.parent().table_model.setData(source_index, data, Qt.EditRole)
        #self.parent().table_model.array_data[source_index.row()][source_index.column()] = not self.parent().table_model.array_data[source_index.row()][source_index.column()]
        #self.parent().model().layoutChanged.emit()


class SortFilterProxyModel(QSortFilterProxyModel):
    def __init__(self, *args, **kwargs):
        QSortFilterProxyModel.__init__(self, *args, **kwargs)
        
    def filterAcceptsRow(self, source_row, source_parent):
        regex = self.filterRegularExpression()

        #iterate over all columns of row
        columns = self.parent().table_model.columnCount(self)
        for i in range(0, columns):
            ix = self.sourceModel().index(source_row, i, source_parent)
            if ix.isValid():
                 text = str(self.sourceModel().data(ix, Qt.DisplayRole))
                 if regex.match(text).hasPartialMatch() or regex.match(text).hasMatch():
                    return True
        return False

class SongTableModel(QAbstractTableModel):
    """
    Adapted from the following: 
    https://stackoverflow.com/questions/22791760/pyqt-adding-rows-to-qtableview-using-qabstracttablemodel
    https://stackoverflow.com/questions/35305801/qt-checkboxes-in-qtableview

    Also see:
    https://stackoverflow.com/questions/15757072/user-editable-checkbox-in-qtableview
    https://stackoverflow.com/questions/1849337/how-can-i-add-a-user-editable-checkbox-in-qtableview-using-only-qstandarditemmod

    """
    def __init__(self, data, headers, parent=None):
        """
        :param data: 2D array of data
        :param headers: Array of strings.
        :param parent: Parent of model.
        """
        QAbstractTableModel.__init__(self, parent)
        self.array_data = data
        self.header_data = headers
    
    def flags(self, index):
        """
        :param index: of type QtCore.QModelIndex
        """
        if index.column() == 1 or index.column() == 2:
            #return QAbstractTableModel.flags(index) | Qt.ItemIsUserCheckable
            return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsUserCheckable | Qt.ItemIsEditable
        else:
            #return QAbstractTableModel.flags(index)
            return Qt.ItemIsEnabled | Qt.ItemIsSelectable

    def rowCount(self, parent):
        return len(self.array_data)

    def columnCount(self, parent):
        if len(self.array_data) > 0: 
            return len(self.array_data[0]) 
        return 0

    def data(self, index, role):
        if not index.isValid():
            return None
        elif role != Qt.DisplayRole:
            return None
        return self.array_data[index.row()][index.column()]

    def headerData(self, col, orientation, role):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.header_data[col]
        return None

    def setData(self, index, value, role = Qt.EditRole):     
        if role == Qt.EditRole:             
            self.array_data[index.row()][index.column()] = value
            self.dataChanged.emit(index, index, ())             
            return True         
        else:             
            return False

    def sort(self, Ncol, order):
        """
        Sort table by given column number.
        """
        self.emit(SIGNAL("layoutAboutToBeChanged()"))
        self.array_data = sorted(self.array_data, key=operator.itemgetter(Ncol))       
        if order == Qt.DescendingOrder:
            self.array_data.reverse()
        self.emit(SIGNAL("layoutChanged()"))

class SongView(QTableView):
    def __init__(self, *args, **kwargs):
        # QWidget.__init__(self, *args, **kwargs)
        super().__init__()

        self.headers = ['a', 'b', 'c', 'd', 'e']
        self.data = [[1, 1, 0, 2, 3],
        [3, 1, 0, "ab", 3],
        [4, 1, 0, 2, "sdf"],
        [2, 1, 0, "sdfd", 3],
        [5, 1, 0, 2, "sdfd"]]

        self.table_model = SongTableModel(self.data, self.headers, self)
        
        self.proxy = SortFilterProxyModel(self)
        self.proxy.setSourceModel(self.table_model)

        self.setModel(self.proxy)
        self.setSortingEnabled(True)

        #Checkbox stuff
        delegate = CheckBoxDelegate(self)
        self.setItemDelegateForColumn(1, delegate)
        '''
        for row in range(4):
            for column in range(3):
                index = self.table_model.index(row, column, QModelIndex())
                self.table_model.setData(index, 1)
        '''


class Widget(QWidget):
    def __init__(self, *args, **kwargs):
        QWidget.__init__(self, *args, **kwargs)
        self.setLayout(QVBoxLayout())

        tv1 = SongView()
        self.layout().addWidget(tv1)

        flayout = QFormLayout()
        self.layout().addLayout(flayout)
        
        self.le = QLineEdit(self)
        flayout.addRow("Search", self.le)
        self.le.textChanged.connect(lambda text: tv1.proxy.setFilterRegularExpression(text))
    def update_filter(self):
        print(self.le.text())
        self.proxy.setFilterRegularExpression(self.le.text())
        self.proxy.invalidateFilter()
        '''
        for i in range(model.columnCount()):
            le = QLineEdit(self)
            flayout.addRow("column: {}".format(i), le)
            le.textChanged.connect(lambda text, col=i:
                                   self.proxy.setFilterByColumn(QRegularExpression(text), col))
        '''
        '''
        for i in range(model.columnCount()):
            le = QLineEdit(self)
            flayout.addRow("column: {}".format(i), le)
            le.textChanged.connect(lambda text, col=i:
                                   proxy.filterRegularExpression(QRegularExpression(text)))
        '''

if __name__ == '__main__':
    import sys

    app = QApplication(sys.argv)
    w = Widget()
    w.show()
    sys.exit(app.exec())
